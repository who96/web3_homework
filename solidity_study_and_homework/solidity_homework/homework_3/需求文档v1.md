# NFT拍卖市场需求文档 v1.0

## 项目概述

构建一个基于Foundry的NFT拍卖市场，集成Chainlink Price Feed实现ETH到USD的价格转换。采用渐进式开发：先实现核心拍卖功能，后扩展工厂模式和代理升级。

## 核心数据结构

### 拍卖结构体
```solidity
struct Auction {
    address nftContract;      // NFT合约地址
    uint256 tokenId;          // NFT token ID
    address seller;           // 卖家地址
    uint256 startTime;        // 拍卖开始时间（timestamp）
    uint256 duration;         // 拍卖持续时间（秒）
    uint256 reservePrice;     // 最低价格（wei，ETH单位）
    address highestBidder;    // 当前最高出价者
    uint256 highestBid;       // 当前最高出价（wei）
    bool ended;              // 拍卖是否结束
    bool claimed;            // NFT是否已领取
}
```

## 功能规格

### 1. 拍卖机制
- **拍卖类型**: 英式拍卖（价格递增）
- **出价货币**: 仅支持ETH
- **时长配置**: 可配置，按秒为单位（建议最小值3600秒）
- **最小增幅**: 上次出价的5%
- **平台手续费**: 3%（从最终成交价扣除）

### 2. 价格显示
- 使用Chainlink ETH/USD Price Feed
- 合约内部以ETH计算，前端显示USD等值
- 仅用于显示，不影响拍卖逻辑

### 3. 拍卖流程
```text
创建拍卖 → 出价竞争 → 手动提取退款 → 自动结束 → 领取NFT/资金
```

**退款机制说明：**
- 被超越的出价者需要手动调用`withdrawRefund()`提取退款
- 用户承担自己的退款Gas费用，避免平台经济负担
- 消除恶意频繁出价的攻击向量
- 提取功能包含重入攻击防护

## 技术架构

### 阶段一：核心拍卖合约

#### AuctionContract.sol
```solidity
contract SimpleAuction {
    // 核心存储
    mapping(uint256 => Auction) public auctions;
    uint256 public auctionCounter;

    // Chainlink Price Feed
    AggregatorV3Interface internal priceFeed;

    // 平台配置
    uint256 public constant PLATFORM_FEE = 300; // 3% = 300/10000
    address public platformWallet;

    // 核心函数
    function createAuction(...) external;
    function placeBid(uint256 auctionId) external payable;
    function withdrawRefund() external;
    function endAuction(uint256 auctionId) external;
    function claimNFT(uint256 auctionId) external;
    function claimFunds(uint256 auctionId) external;
}
```

#### ERC721Contract.sol
```solidity
contract SimpleNFT is ERC721, Ownable {
    uint256 private _tokenCounter;

    function mint(address to, string memory uri) external;
    function setApprovalForAll(address operator, bool approved) external;
}
```

### 阶段二：工厂模式扩展（后续）

### 阶段三：透明代理升级实现

#### 代理架构选择
- **代理模式**: OpenZeppelin透明代理 (TransparentUpgradeableProxy)
- **选择理由**: 安全优先、简单清晰、经过充分验证
- **Gas开销**: 可接受的额外成本换取安全性

#### 透明代理组件

##### ProxyAdmin.sol
```solidity
// OpenZeppelin标准管理合约
import "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";

contract AuctionProxyAdmin is ProxyAdmin {
    constructor(address initialOwner) ProxyAdmin(initialOwner) {}
}
```

##### AuctionProxy.sol
```solidity
// 透明代理合约
import "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

contract AuctionProxy is TransparentUpgradeableProxy {
    constructor(
        address implementation,
        address admin,
        bytes memory data
    ) TransparentUpgradeableProxy(implementation, admin, data) {}
}
```

##### 可升级的拍卖合约
```solidity
// 继承Initializable而不是constructor
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

contract SimpleAuctionUpgradeable is Initializable, ReentrancyGuardUpgradeable {
    // 存储布局 - 永远只能追加，不能修改顺序
    mapping(uint256 => Auction) public auctions;
    uint256 public auctionCounter;
    AggregatorV3Interface internal priceFeed;
    uint256 public constant PLATFORM_FEE = 300;
    address public platformWallet;

    function initialize(
        address _priceFeed,
        address _platformWallet
    ) public initializer {
        __ReentrancyGuard_init();
        priceFeed = AggregatorV3Interface(_priceFeed);
        platformWallet = _platformWallet;
    }

    // 核心业务函数保持不变
    function createAuction(...) external { }
    function placeBid(uint256 auctionId) external payable { }
    function withdrawRefund() external { }
    // ...其他函数
}
```

#### 升级流程
```text
1. 部署新的实现合约
2. 通过ProxyAdmin调用upgrade()
3. 如需要，调用新的初始化函数
4. 验证升级成功
```

#### 存储布局规则
```solidity
// V1 存储布局
contract SimpleAuctionV1 {
    mapping(uint256 => Auction) public auctions;  // slot 0
    uint256 public auctionCounter;                // slot 1
    AggregatorV3Interface internal priceFeed;     // slot 2
    address public platformWallet;               // slot 3
}

// V2 升级时只能追加，不能修改
contract SimpleAuctionV2 {
    // V1的所有变量保持不变
    mapping(uint256 => Auction) public auctions;  // slot 0 - 不变
    uint256 public auctionCounter;                // slot 1 - 不变
    AggregatorV3Interface internal priceFeed;     // slot 2 - 不变
    address public platformWallet;               // slot 3 - 不变

    // V2新增变量追加在后面
    uint256 public minimumDuration;              // slot 4 - 新增
    mapping(address => bool) public blacklist;   // slot 5 - 新增
}
```

## 安全考虑

### 1. 重入攻击防护
- 使用ReentrancyGuard
- 状态更新在外部调用之前

### 2. 资金安全
- 被超越出价可手动提取退款
- 用户承担自己的退款Gas费用
- 拍卖取消时退还NFT

### 3. 价格操纵防护
- Oracle价格仅用于显示
- 拍卖逻辑基于ETH数量

### 4. 权限控制
- NFT所有者才能创建拍卖
- 合约需要NFT授权

## 开发环境

### 技术栈
- **基础框架**: [smartcontractkit/foundry-starter-kit](https://github.com/smartcontractkit/foundry-starter-kit)
  - Foundry框架 (预配置)
  - Chainlink Price Feed集成 (已实现PriceFeedConsumer)
  - 多链支持 (Sepolia等测试网配置完整)
  - 标准项目结构 (src/, script/, test/)
- **合约标准**: ERC721, ERC165
- **Oracle服务**: Chainlink ETH/USD Price Feed (复用已有集成)
- **代理模式**: OpenZeppelin透明代理 (Phase 3)
- **升级库**: @openzeppelin/contracts-upgradeable

### 环境配置 (基于starter kit)
**已预配置项 (直接可用):**
- ✅ Foundry.toml优化配置
- ✅ Chainlink合约导入
- ✅ 基础测试框架
- ✅ 部署脚本模板

**需要补充配置:**
- RPC端点: Sepolia Gateway
- 验证服务: Etherscan API Key
- 测试私钥: 开发用途

## 实现计划

### Phase 1: 基础实现 (Week 1) - 基于starter kit快速启动
1. **项目初始化** (Day 1)
   - Fork [smartcontractkit/foundry-starter-kit](https://github.com/smartcontractkit/foundry-starter-kit)
   - 验证Foundry环境和依赖
   - 理解已有的PriceFeedConsumer实现

2. **核心合约开发** (Day 2-4)
   - 实现SimpleNFT合约 (基于ERC721标准)
   - 复用PriceFeedConsumer逻辑，修改为拍卖场景
   - 实现SimpleAuction核心功能

3. **集成测试** (Day 5-7)
   - 利用starter kit的测试框架
   - 编写基础测试用例
   - 本地Anvil网络验证

### Phase 2: 完善功能 (Week 2) - 生产就绪
1. **安全加固** (Day 1-3)
   - 添加ReentrancyGuard防护
   - 完善错误处理和边界检查
   - 手动退款机制实现

2. **测试覆盖** (Day 4-5)
   - 利用starter kit的部署脚本模板
   - 全面单元和集成测试
   - Gas费用优化分析

3. **测试网部署** (Day 6-7)
   - 复用已配置的Sepolia环境
   - 合约验证和交互测试

### Phase 3: 代理升级实现 (Week 3) - 企业级架构
1. **可升级架构重构** (Day 1-3)
   - 重构SimpleAuction为Initializable版本
   - 实现ProxyAdmin和透明代理
   - 存储布局兼容性设计

2. **代理部署测试** (Day 4-5)
   - 部署透明代理架构到Sepolia
   - 升级流程验证
   - 状态数据持久性测试

3. **文档和脚本** (Day 6-7)
   - 编写升级操作脚本
   - 部署和升级文档
   - 最终验收测试

## 测试要求

### 单元测试覆盖
- [] NFT mint和transfer
- [] 拍卖创建和配置
- [] 出价逻辑和验证
- [] 手动退款功能和防护
- [] 拍卖结束和资金分配
- [] 异常情况处理
- [] 代理初始化和升级
- [] 存储布局兼容性

### 集成测试场景
- [] 完整拍卖流程
- [] 多用户竞价和退款
- [] 边界条件测试
- [] Gas费用分析
- [] 代理升级流程测试
- [] 升级后功能验证

## 部署清单 (基于starter kit部署脚本)

### 环境准备 (利用starter kit配置)
```bash
# 1. Fork并克隆项目
git clone <your-fork-of-foundry-starter-kit>
cd foundry-starter-kit

# 2. 安装依赖 (利用已有配置)
forge install

# 3. 环境变量设置 (基于starter kit的.env.example)
cp .env.example .env
# 编辑 SEPOLIA_RPC_URL, ETHERSCAN_API_KEY, PRIVATE_KEY
```

### Phase 1 & 2: 基础部署 (利用starter kit部署框架)
```bash
# 1. 部署SimpleNFT合约
forge script script/DeploySimpleNFT.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast --verify

# 2. 部署SimpleAuction合约 (集成Chainlink Price Feed)
# 复用starter kit中的SEPOLIA_PRICE_FEED_ADDRESS
forge script script/DeploySimpleAuction.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast --verify

# 3. 验证和测试 (利用已有测试框架)
forge test --rpc-url $SEPOLIA_RPC_URL
```

### Phase 3: 代理部署 (企业级升级架构)
```bash
# 1. 部署可升级实现合约
forge script script/DeployAuctionUpgradeable.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast --verify

# 2. 部署代理管理架构
forge script script/DeployAuctionProxy.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast --verify

# 3. 初始化和验证
forge script script/InitializeAuctionProxy.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast

# 4. 升级测试脚本
forge script script/UpgradeAuction.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast
```

### 验证清单

#### 基础功能验证
- [ ] NFT mint功能正常
- [ ] 拍卖创建成功
- [ ] 出价和退款正常
- [ ] 价格显示准确
- [ ] 手续费计算正确

#### 代理功能验证
- [ ] 代理初始化成功
- [ ] 通过代理调用业务函数正常
- [ ] 升级实现合约成功
- [ ] 升级后状态数据保持完整
- [ ] 存储布局兼容性验证

---

**工程原则**: "先让它跑起来，再让它跑得好，最后让它跑得快"

**安全第一**: 每个外部调用都要考虑攻击向量

**KISS原则**: 简单直接的解决方案优于复杂的架构